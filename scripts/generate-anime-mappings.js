#!/usr/bin/env node

/**
 * Generate anime-mappings.ts from anime-subreddits.yaml
 * Single source of truth: YAML file
 * Output: TypeScript file optimized for runtime
 * Run: node scripts/generate-anime-mappings.js
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

// Simple YAML parser (handles the anime mapping structure)
function parseYAML(content) {
  const lines = content.split('\n');
  const anime = [];
  let currentAnime = null;

  for (const line of lines) {
    const trimmed = line.trim();

    // Skip comments and empty lines
    if (!trimmed || trimmed.startsWith('#')) {
      continue;
    }

    // New anime entry
    if (trimmed.startsWith('- title:')) {
      if (currentAnime) {
        anime.push(currentAnime);
      }
      const title = trimmed.match(/- title: "([^"]+)"/)?.[1];
      currentAnime = {
        title,
        subreddits: [],
        aliases: [],
        season_specific: false,
      };
    }

    // Parse subreddits
    if (trimmed.startsWith('subreddits:')) {
      const match = trimmed.match(/subreddits:\s*\[(.*?)\]/);
      if (match) {
        const subreddits = match[1]
          .split(',')
          .map((s) => s.trim().replace(/"/g, ''));
        if (currentAnime) {
          currentAnime.subreddits = subreddits;
        }
      }
    }

    // Parse aliases
    if (trimmed.startsWith('aliases:')) {
      const match = trimmed.match(/aliases:\s*\[(.*?)\]/);
      if (match) {
        const aliases = match[1]
          .split(',')
          .map((a) => a.trim().replace(/"/g, ''));
        if (currentAnime) {
          currentAnime.aliases = aliases;
        }
      }
    }

    // Parse season_specific
    if (trimmed.startsWith('season_specific:')) {
      const value = trimmed.includes('true');
      if (currentAnime) {
        currentAnime.season_specific = value;
      }
    }
  }

  if (currentAnime) {
    anime.push(currentAnime);
  }

  return anime;
}

// Generate TypeScript file
function generateTypeScriptFile(anime) {
  const typeDefinition = `/**
 * Auto-generated from src/config/anime-subreddits.yaml
 * DO NOT EDIT THIS FILE DIRECTLY
 * Run: pnpm generate:anime
 */

export interface AnimeMapping {
  title: string;
  subreddits: string[];
  aliases: string[];
  season_specific: boolean;
}

export const ANIME_MAPPINGS: AnimeMapping[] = ${JSON.stringify(anime, null, 2)};

/**
 * Find anime mapping by title (with fuzzy matching support for aliases)
 * @param title Anime title to search for
 * @returns AnimeMapping if found, null otherwise
 */
export function findAnimeMapping(title: string): AnimeMapping | null {
  if (!title) return null;

  const normalizedInput = title.toLowerCase().trim();

  // Exact match on title first
  let found = ANIME_MAPPINGS.find((a) => a.title.toLowerCase() === normalizedInput);
  if (found) return found;

  // Check aliases
  found = ANIME_MAPPINGS.find((a) =>
    a.aliases.some((alias) => alias.toLowerCase() === normalizedInput),
  );
  if (found) return found;

  // Partial match on title (contains)
  found = ANIME_MAPPINGS.find((a) => a.title.toLowerCase().includes(normalizedInput));
  if (found) return found;

  // Partial match on aliases
  found = ANIME_MAPPINGS.find((a) =>
    a.aliases.some((alias) => alias.toLowerCase().includes(normalizedInput)),
  );

  return found || null;
}

/**
 * Get subreddit list for an anime (with fallback)
 * @param title Anime title
 * @returns Array of subreddit names to search
 */
export function getSubredditsForAnime(title: string): string[] {
  const mapping = findAnimeMapping(title);
  return mapping?.subreddits || [];
}
`;

  return typeDefinition;
}

// Main execution
async function main() {
  const yamlPath = path.join(__dirname, '../data/ANIMESUBREDDITS.yaml');
  const tsPath = path.join(__dirname, '../src/config/anime-mappings.ts');

  try {
    // Read YAML file
    const yamlContent = fs.readFileSync(yamlPath, 'utf-8');
    console.log(`üìñ Reading YAML: ${yamlPath}`);

    // Parse YAML
    const anime = parseYAML(yamlContent);
    console.log(`‚úÖ Parsed ${anime.length} anime from YAML`);

    // Validate
    if (anime.length === 0) {
      console.error('‚ùå No anime found in YAML file');
      process.exit(1);
    }

    // Generate TypeScript
    const tsContent = generateTypeScriptFile(anime);

    // Write TypeScript file
    fs.writeFileSync(tsPath, tsContent);
    console.log(`üìù Generated: ${tsPath}`);

    // Summary
    console.log(`
‚ú® Success! Generated anime-mappings.ts
   ‚Ä¢ Source: data/ANIMESUBREDDITS.yaml
   ‚Ä¢ Output: src/config/anime-mappings.ts (TypeScript)
   ‚Ä¢ Anime count: ${anime.length}
   ‚Ä¢ No data duplication (YAML is source of truth)
    `);
  } catch (error) {
    console.error('‚ùå Error generating anime mappings:', error.message);
    process.exit(1);
  }
}

main();
